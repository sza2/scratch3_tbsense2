const ArgumentType = require('../../extension-support/argument-type');
const BlockType = require('../../extension-support/block-type');
const log = require('../../util/log');
const cast = require('../../util/cast');
const formatMessage = require('format-message');
const BLE = require('../../io/ble');
const Base64Util = require('../../util/base64-util');
const { toNumber } = require('../../util/cast');
const { time } = require('format-message');

/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len
const blockIconURI = 'data:image/png;base64,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';

/**
 * Enum for TB Sense 2 BLE command protocol.
 * https://github.com/LLK/scratch-TbSense2-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */
const BLECommand = {
    CMD_LED_STATE: 0x01,
    CMD_LED_COLOR: 0x02,
};


/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */
const BLETimeout = 4500;

/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */
const BLESendInterval = 20;

/**
 * A string to report to the BLE socket when the TB Sense 2 has stopped receiving data.
 * @type {string}
 */
const BLEDataStoppedError = 'TB Sense 2 extension stopped receiving data';

/**
 * Enum for TB Sense 2 protocol.
 * @readonly
 * @enum {string}
 */
const BLEUUID = {
    service: '82a1cb00-3921-4c9c-ba34-34f78bab9a1b',
    rxChar: '82a1cb01-3921-4c9c-ba34-34f78bab9a1b',
    txChar: '82a1cb02-3921-4c9c-ba34-34f78bab9a1b'
};

/**
 * Manage communication with a TbSense2 peripheral over a Scrath Link client socket.
 */
class TbSense2 {

    /**
     * Construct a TbSense2 communication object.
     * @param {Runtime} runtime - the Scratch 3.0 runtime
     * @param {string} extensionId - the id of the extension
     */
    constructor (runtime, extensionId) {

        /**
         * The Scratch 3.0 runtime used to trigger the green flag button.
         * @type {Runtime}
         * @private
         */
        this._runtime = runtime;

        /**
         * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
         * @type {BLE}
         * @private
         */
        this._ble = null;
        this._runtime.registerPeripheralExtension(extensionId, this);

        /**
         * The id of the extension this peripheral belongs to.
         */
        this._extensionId = extensionId;

        /**
         * The most recently received value for each sensor.
         * @type {Object.<string, number>}
         * @private
         */
        this._sensors = {
            tiltX: 0,
            tiltY: 0,
            buttonA: 0,
            buttonB: 0,
            ledRGBState: new Uint8Array(2),
            ledRGBColor: new Uint8Array(3)
        };

        /**
         * Interval ID for data reading timeout.
         * @type {number}
         * @private
         */
        this._timeoutID = null;

        /**
         * A flag that is true while we are busy sending data to the BLE socket.
         * @type {boolean}
         * @private
         */
        this._busy = false;

        /**
         * ID for a timeout which is used to clear the busy flag if it has been
         * true for a long time.
         */
        this._busyTimeoutID = null;

        this.reset = this.reset.bind(this);
        this._onConnect = this._onConnect.bind(this);
        this._onMessage = this._onMessage.bind(this);
    }

    /**
     * @param {Uint8Array} color - the color of the LEDs.
     * @return {Promise} - a Promise that resolves when writing to peripheral.
     */
    setRGBLedColor (color) {
        return this.send(BLECommand.CMD_LED_COLOR, color);
    }

    /**
     * @param {Uint8Array} state - the state of the LEDs.
     * @return {Promise} - a Promise that resolves when writing to peripheral.
     */
    setLedState (state) {
        return this.send(BLECommand.CMD_LED_STATE, state);
    }

    /**
     * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
     */
    get tiltX () {
        return this._sensors.tiltX;
    }

    /**
     * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
     */
    get tiltY () {
        return this._sensors.tiltY;
    }

    /**
     * @return {boolean} - the latest value received for the A button.
     */
    get buttonA () {
        return this._sensors.buttonA;
    }

    /**
     * @return {boolean} - the latest value received for the B button.
     */
    get buttonB () {
        return this._sensors.buttonB;
    }

    /**
     * @return {Uint8Array} - the current state of the RGB LEDs.
     */
    get ledRGBColor () {
        return this._sensors.ledRGBColor;
    }

    /**
     * @return {Uint8Array} - the current state of the RGB LEDs.
     */
    get ledRGBState () {
        return this._sensors.ledRGBState;
    }

    /**
     * Called by the runtime when user wants to scan for a peripheral.
     */
    scan () {
        if (this._ble) {
            this._ble.disconnect();
        }
        this._ble = new BLE(this._runtime, this._extensionId, {
            filters: [
                {services: [BLEUUID.service]}
            ]
        }, this._onConnect, this.reset);
    }

    /**
     * Called by the runtime when user wants to connect to a certain peripheral.
     * @param {number} id - the id of the peripheral to connect to.
     */
    connect (id) {
        if (this._ble) {
            this._ble.connectPeripheral(id);
        }
    }

    /**
     * Disconnect from the TB Sense 2.
     */
    disconnect () {
        if (this._ble) {
            this._ble.disconnect();
        }

        this.reset();
    }

    /**
     * Reset all the state and timeout/interval ids.
     */
    reset () {
        if (this._timeoutID) {
            window.clearTimeout(this._timeoutID);
            this._timeoutID = null;
        }
    }

    /**
     * Return true if connected to the TB Sense 2.
     * @return {boolean} - whether the TB Sense 2 is connected.
     */
    isConnected () {
        let connected = false;
        if (this._ble) {
            connected = this._ble.isConnected();
        }
        return connected;
    }

    /**
     * Send a message to the peripheral BLE socket.
     * @param {number} command - the BLE command hex.
     * @param {Uint8Array} message - the message to write
     */
    send (command, message) {
        if (!this.isConnected()) return;
        if (this._busy) return;

        // Set a busy flag so that while we are sending a message and waiting for
        // the response, additional messages are ignored.
        this._busy = true;

        // Set a timeout after which to reset the busy flag. This is used in case
        // a BLE message was sent for which we never received a response, because
        // e.g. the peripheral was turned off after the message was sent. We reset
        // the busy flag after a while so that it is possible to try again later.
        this._busyTimeoutID = window.setTimeout(() => {
            this._busy = false;
        }, 5000);

        const output = new Uint8Array(message.length + 1);
        output[0] = command; // attach command to beginning of message
        for (let i = 0; i < message.length; i++) {
            output[i + 1] = message[i];
        }
        const data = Base64Util.uint8ArrayToBase64(output);

        this._ble.write(BLEUUID.service, BLEUUID.txChar, data, 'base64', true).then(
            () => {
                this._busy = false;
                window.clearTimeout(this._busyTimeoutID);
            }
        );
    }

    /**
     * Starts reading data from peripheral after BLE has connected to it.
     * @private
     */
    _onConnect () {
        this._ble.read(BLEUUID.service, BLEUUID.rxChar, true, this._onMessage);
        this._timeoutID = window.setTimeout(
            () => this._ble.handleDisconnectError(BLEDataStoppedError),
            BLETimeout
        );
    }

    /**
     * Process the sensor data from the incoming BLE characteristic.
     * @param {object} base64 - the incoming BLE data.
     * @private
     */
    _onMessage (base64) {
        // parse data
        const data = Base64Util.base64ToUint8Array(base64);

        this._sensors.tiltX = data[1] | (data[0] << 8);
        if (this._sensors.tiltX > (1 << 15)) this._sensors.tiltX -= (1 << 16);
        this._sensors.tiltY = data[3] | (data[2] << 8);
        if (this._sensors.tiltY > (1 << 15)) this._sensors.tiltY -= (1 << 16);

        this._sensors.buttonA = data[4];
        this._sensors.buttonB = data[5];

        // cancel disconnect timeout and start a new one
        window.clearTimeout(this._timeoutID);
        this._timeoutID = window.setTimeout(
            () => this._ble.handleDisconnectError(BLEDataStoppedError),
            BLETimeout
        );
    }
}

/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */
const TbSense2TiltDirection = {
    FRONT: 'front',
    BACK: 'back',
    LEFT: 'left',
    RIGHT: 'right',
    ANY: 'any'
};

/**
 * Enum for TB Sense 2 buttons.
 * @readonly
 * @enum {string}
 */
const TbSense2Buttons = {
    A: 'A',
    B: 'B',
    ANY: 'any'
};

/**
 * Enum for TB Sense 2 LEDs.
 * @readonly
 * @enum {string}
 */
const TbSense2Leds = {
    LED0: '1',
    LED1: '2',
    LED2: '3',
    LED3: '4',
    LEDALL: 'ALL'
};

/**
 * Scratch 3.0 blocks to interact with a TbSense2 peripheral.
 */
class Scratch3TbSense2Blocks {

    /**
     * @return {string} - the name of this extension.
     */
    static get EXTENSION_NAME () {
        return 'TB Sense 2';
    }

    /**
     * @return {string} - the ID of this extension.
     */
    static get EXTENSION_ID () {
        return 'tbsense2';
    }

    /**
     * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
     */
    static get TILT_THRESHOLD () {
        return 15;
    }

    /**
     * @return {array} - text and values for each LEDs menu element
     */
    get LEDS_MENU () {
        return [
            {
                text: '1',
                value: TbSense2Leds.LED0
            },
            {
                text: '2',
                value: TbSense2Leds.LED1
            },
            {
                text: '3',
                value: TbSense2Leds.LED2
            },
            {
                text: '4',
                value: TbSense2Leds.LED3
            },
            {
                text: formatMessage({
                    id: 'tbsense2.ledsMenu.all',
                    default: 'all',
                    description: 'label for "all" element in LED picker for TB Sense 2 extension'
                }),
                value: TbSense2Leds.LEDALL
            }
        ];
    }

    /**
     * @return {array} - text and values for each buttons menu element
     */
    get BUTTONS_MENU () {
        return [
            {
                text: 'A',
                value: TbSense2Buttons.A
            },
            {
                text: 'B',
                value: TbSense2Buttons.B
            },
            {
                text: formatMessage({
                    id: 'TbSense2.buttonsMenu.any',
                    default: 'any',
                    description: 'label for "any" element in button picker for TB Sense 2 extension'
                }),
                value: TbSense2Buttons.ANY
            }
        ];
    }

    /**
     * @return {array} - text and values for each tilt direction menu element
     */
    get TILT_DIRECTION_MENU () {
        return [
            {
                text: formatMessage({
                    id: 'TbSense2.tiltDirectionMenu.front',
                    default: 'front',
                    description: 'label for front element in tilt direction picker for TB Sense 2 extension'
                }),
                value: TbSense2TiltDirection.FRONT
            },
            {
                text: formatMessage({
                    id: 'TbSense2.tiltDirectionMenu.back',
                    default: 'back',
                    description: 'label for back element in tilt direction picker for TB Sense 2 extension'
                }),
                value: TbSense2TiltDirection.BACK
            },
            {
                text: formatMessage({
                    id: 'TbSense2.tiltDirectionMenu.left',
                    default: 'left',
                    description: 'label for left element in tilt direction picker for TB Sense 2 extension'
                }),
                value: TbSense2TiltDirection.LEFT
            },
            {
                text: formatMessage({
                    id: 'TbSense2.tiltDirectionMenu.right',
                    default: 'right',
                    description: 'label for right element in tilt direction picker for TB Sense 2 extension'
                }),
                value: TbSense2TiltDirection.RIGHT
            }
        ];
    }

    /**
     * @return {array} - text and values for each tilt direction (plus "any") menu element
     */
    get TILT_DIRECTION_ANY_MENU () {
        return [
            ...this.TILT_DIRECTION_MENU,
            {
                text: formatMessage({
                    id: 'TbSense2.tiltDirectionMenu.any',
                    default: 'any',
                    description: 'label for any direction element in tilt direction picker for TB Sense 2 extension'
                }),
                value: TbSense2TiltDirection.ANY
            }
        ];
    }

    /**
     * Construct a set of TbSense2 blocks.
     * @param {Runtime} runtime - the Scratch 3.0 runtime.
     */
    constructor (runtime) {
        /**
         * The Scratch 3.0 runtime.
         * @type {Runtime}
         */
        this.runtime = runtime;

        // Create a new TbSense2 peripheral instance
        this._peripheral = new TbSense2(this.runtime, Scratch3TbSense2Blocks.EXTENSION_ID);
    }

    /**
     * @returns {object} metadata for this extension and its blocks.
     */
    getInfo () {
        return {
            id: Scratch3TbSense2Blocks.EXTENSION_ID,
            name: Scratch3TbSense2Blocks.EXTENSION_NAME,
            blockIconURI: blockIconURI,
            showStatusButton: true,
            blocks: [
                {
                    opcode: 'whenButtonPressed',
                    text: formatMessage({
                        id: 'TbSense2.whenButtonPressed',
                        default: 'when [BTN] button pressed',
                        description: 'when the selected button on the TB Sense 2 is pressed'
                    }),
                    blockType: BlockType.HAT,
                    arguments: {
                        BTN: {
                            type: ArgumentType.STRING,
                            menu: 'buttons',
                            defaultValue: TbSense2Buttons.A
                        }
                    }
                },
                {
                    opcode: 'isButtonPressed',
                    text: formatMessage({
                        id: 'TbSense2.isButtonPressed',
                        default: '[BTN] button pressed?',
                        description: 'is the selected button on the TB Sense 2 pressed?'
                    }),
                    blockType: BlockType.BOOLEAN,
                    arguments: {
                        BTN: {
                            type: ArgumentType.STRING,
                            menu: 'buttons',
                            defaultValue: TbSense2Buttons.A
                        }
                    }
                },
                '---',
                {
                    opcode: 'ledRGBOn',
                    text: formatMessage({
                        id: 'TbSense2.ledRGBOn',
                        default: 'turn LED [LED] on',
                        description: 'turn on the selected RGB LEDs on the TB Sense 2'
                    }),
                    blockType: BlockType.COMMAND,
                    arguments: {
                        LED: {
                            type: ArgumentType.STRING,
                            menu: 'leds',
                            defaultValue: TbSense2Leds.LEDALL
                        }
                    }
                },
                {
                    opcode: 'ledRGBOff',
                    text: formatMessage({
                        id: 'TbSense2.ledRGBOff',
                        default: 'turn LED [LED] off',
                        description: 'turn off the selected RGB LEDs on the TB Sense 2'
                    }),
                    blockType: BlockType.COMMAND,
                    arguments: {
                        LED: {
                            type: ArgumentType.STRING,
                            menu: 'leds',
                            defaultValue: TbSense2Leds.LEDALL
                        }
                    }
                },
                {
                    opcode: 'ledRGBColor',
                    text: formatMessage({
                        id: 'TbSense2.ledRGBColor',
                        default: 'set [COLOR] color',
                        description: 'set the color of the RGB LEDs on the TB Sense 2'
                    }),
                    blockType: BlockType.COMMAND,
                    arguments: {
                        COLOR: {
                            type: ArgumentType.COLOR,
                            defaultValue: '#ff0000'
                        }
                    }
                },
                '---',
                {
                    opcode: 'whenTilted',
                    text: formatMessage({
                        id: 'TbSense2.whenTilted',
                        default: 'when tilted [DIRECTION]',
                        description: 'when the TB Sense 2 is tilted in a direction'
                    }),
                    blockType: BlockType.HAT,
                    arguments: {
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'tiltDirectionAny',
                            defaultValue: TbSense2TiltDirection.ANY
                        }
                    }
                },
                {
                    opcode: 'isTilted',
                    text: formatMessage({
                        id: 'TbSense2.isTilted',
                        default: 'tilted [DIRECTION]?',
                        description: 'is the TB Sense 2 is tilted in a direction?'
                    }),
                    blockType: BlockType.BOOLEAN,
                    arguments: {
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'tiltDirectionAny',
                            defaultValue: TbSense2TiltDirection.ANY
                        }
                    }
                },
                {
                    opcode: 'getTiltAngle',
                    text: formatMessage({
                        id: 'TbSense2.tiltAngle',
                        default: 'tilt angle [DIRECTION]',
                        description: 'how much the TB Sense 2 is tilted in a direction'
                    }),
                    blockType: BlockType.REPORTER,
                    arguments: {
                        DIRECTION: {
                            type: ArgumentType.STRING,
                            menu: 'tiltDirection',
                            defaultValue: TbSense2TiltDirection.FRONT
                        }
                    }
                },
            ],
            menus: {
                leds: {
                    acceptReporters: true,
                    items: this.LEDS_MENU
                },
                buttons: {
                    acceptReporters: true,
                    items: this.BUTTONS_MENU
                },
                tiltDirection: {
                    acceptReporters: true,
                    items: this.TILT_DIRECTION_MENU
                },
                tiltDirectionAny: {
                    acceptReporters: true,
                    items: this.TILT_DIRECTION_ANY_MENU
                },
            }
        };
    }

    /**
     * Test whether the A or B button is pressed
     * @param {object} args - the block's arguments.
     * @return {boolean} - true if the button is pressed.
     */
    whenButtonPressed (args) {
        if (args.BTN === 'any') {
            return this._peripheral.buttonA | this._peripheral.buttonB;
        } else if (args.BTN === 'A') {
            return this._peripheral.buttonA;
        } else if (args.BTN === 'B') {
            return this._peripheral.buttonB;
        }
        return false;
    }

    /**
     * Test whether the A or B button is pressed
     * @param {object} args - the block's arguments.
     * @return {boolean} - true if the button is pressed.
     */
    isButtonPressed (args) {
        if (args.BTN === 'any') {
            return (this._peripheral.buttonA | this._peripheral.buttonB) !== 0;
        } else if (args.BTN === 'A') {
            return this._peripheral.buttonA !== 0;
        } else if (args.BTN === 'B') {
            return this._peripheral.buttonB !== 0;
        }
        return false;
    }

    /**
     * Set the color of the four LEDs.
     * @param {object} args - the block's arguments.
     * @return {Promise} - a Promise that resolves after a tick.
     */
    ledRGBColor (args) {
        let color = parseInt(args.COLOR.replace('#', ''), 16);
        this._peripheral.ledRGBColor[0] = (color >> 16) & 0xff;
        this._peripheral.ledRGBColor[1] = (color >> 8) & 0xff;
        this._peripheral.ledRGBColor[2] = color & 0xff;
        this._peripheral.setRGBLedColor(this._peripheral.ledRGBColor);
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, BLESendInterval);
        });
    }

    /**
     * Turn off LEDs.
     * @param {object} args - the block's arguments.
     * @return {Promise} - a Promise that resolves after a tick.
     */
    ledRGBOff (args) {
        if (args.LED == '1') {
            this._peripheral.ledRGBState[0] = 0;
        }
        if (args.LED == '2') {
            this._peripheral.ledRGBState[0] = 1;
        }
        if (args.LED == '3') {
            this._peripheral.ledRGBState[0] = 2;
        }
        if (args.LED == '4') {
            this._peripheral.ledRGBState[0] = 3;
        }
        if (args.LED == 'ALL') {
            this._peripheral.ledRGBState[0] = 4;
        }
        this._peripheral.ledRGBState[1] = 0;
        this._peripheral.setLedState(this._peripheral.ledRGBState);
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, BLESendInterval);
        });
    }

    /**
     * Turn on LEDs.
     * @param {object} args - the block's arguments.
     * @return {Promise} - a Promise that resolves after a tick.
     */
    ledRGBOn (args) {
        var d = new Date();
        console.log("ledRGBon", d.getTime());
        if (args.LED == '1') {
            this._peripheral.ledRGBState[0] = 0;
        }
        if (args.LED == '2') {
            this._peripheral.ledRGBState[0] = 1;
        }
        if (args.LED == '3') {
            this._peripheral.ledRGBState[0] = 2;
        }
        if (args.LED == '4') {
            this._peripheral.ledRGBState[0] = 3;
        }
        if (args.LED == 'ALL') {
            this._peripheral.ledRGBState[0] = 4;
        }
        this._peripheral.ledRGBState[1] = 1;
        this._peripheral.setLedState(this._peripheral.ledRGBState);
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, BLESendInterval);
        });
    }

    /**
     * Test whether the tilt sensor is currently tilted.
     * @param {object} args - the block's arguments.
     * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
     */
    whenTilted (args) {
        return this._isTilted(args.DIRECTION);
    }

    /**
     * Test whether the tilt sensor is currently tilted.
     * @param {object} args - the block's arguments.
     * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
     */
    isTilted (args) {
        return this._isTilted(args.DIRECTION);
    }

    /**
     * @param {object} args - the block's arguments.
     * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.
     * @return {number} - the tilt sensor's angle in the specified direction.
     * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
     */
    getTiltAngle (args) {
        return this._getTiltAngle(args.DIRECTION);
    }

    /**
     * Test whether the tilt sensor is currently tilted.
     * @param {TiltDirection} direction - the tilt direction to test (front, back, left, right, or any).
     * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
     * @private
     */
    _isTilted (direction) {
        switch (direction) {
        case TbSense2TiltDirection.ANY:
            return (Math.abs(this._peripheral.tiltX / 10) >= Scratch3TbSense2Blocks.TILT_THRESHOLD) ||
                (Math.abs(this._peripheral.tiltY / 10) >= Scratch3TbSense2Blocks.TILT_THRESHOLD);
        default:
            return this._getTiltAngle(direction) >= Scratch3TbSense2Blocks.TILT_THRESHOLD;
        }
    }

    /**
     * @param {TiltDirection} direction - the direction (front, back, left, right) to check.
     * @return {number} - the tilt sensor's angle in the specified direction.
     * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
     * @private
     */
    _getTiltAngle (direction) {
        switch (direction) {
        case TbSense2TiltDirection.FRONT:
            return Math.round(this._peripheral.tiltY / -10);
        case TbSense2TiltDirection.BACK:
            return Math.round(this._peripheral.tiltY / 10);
        case TbSense2TiltDirection.LEFT:
            return Math.round(this._peripheral.tiltX / -10);
        case TbSense2TiltDirection.RIGHT:
            return Math.round(this._peripheral.tiltX / 10);
        default:
            log.warn(`Unknown tilt direction in _getTiltAngle: ${direction}`);
        }
    }

}

module.exports = Scratch3TbSense2Blocks;
